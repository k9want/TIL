# 오버라이딩

조상 클래스로부터 상속 받은 메서드의 내용을 변경하는 것

상속받은 메서드를 그대로 사용할 때도 있지만, 자손 클래스에 맞게 변경하는 경우 조상의 메서드를 오버라이딩한다. 

### 오버라이딩 조건

메서드의 내용만 새로 작성, 선언부는 조상의 것 그대로 (이름, 매개변수, 반환타입) 

주의할 점

1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다. 
2. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다. 
3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다. 

조상 클래스와 자손 클래스에 똑같은 이름의 static메서드를 정의하는 것은 각 클래스에 별개의 static메서드를 정의하는 것이지 오버라이딩이 아니다. 

### 오버로딩 vs 오버라이딩

오버로딩 - 기존에 없는 새로운 메서드를 정의하는 것 (new)

오버라이딩 - 조상으로부터 상속받은 메서드의 내용을 변경하는 것 (change, modify) 

### super

**자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수**

멤법변수와 지역변수 이름이 같을 때 this로 구별하듯이 상속받은 멤버와 지신의 멤버와 이름이 같을 때는 super로 구별한다. 

모든 인스턴스메서드에 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데, 이것이 참조변수인 this, super값이 된다. 

조상클래스의 메서드의 내용에 추가적으로 작업을 하는 경우라면 super를 사용해서 조상클래스의 메서드를 포함시킬 수 있다. 

### super( ) - 조상 클래스의 생성자

this( )처럼 super( )도 생성자이다. 

this( ) - 같은 클래스의 다른 생성자를 호출할 때 사용

super( ) - 조상클래스의 생성자를 호출할 때 사용

자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다. 그렇기 때문에 자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용할 수 있는 것이다. 

**주의! 이 때!!** **조상 클래스 멤버의 초기화 작업이 수행되어야 하기 때문에 자손클래스의 생성자에서 조상 클래스의 호출자가 호출되어야 한다.** 

생성자의 첫 줄에 조상클래스의 생성자를 호출해야하는 이유?

자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야 하기 때문에 

- Object클래스를 제외한 모든 클래스의 생성자 첫줄에 생성자.this( ) 또는 super( )를 호출해야 한다.
- 그렇지 않으면 컴파일러가 자동적으로 super( );를 생성자의 첫줄에 삽입한다.

**조상 클래스의 멤버변수는 조상의 생성자에 의해 초기화되도록 해야한다.**