# 제어자(modifier)

클래스, 변수 또는 메서드의 선언부와 함께 사용되어 부가적인 의미를 부여한다. 

- 접근 제어자 - public, protected, default, private
- 그 외 - static, final, abstract, native, transient, synchronized, volatile, strictfp

### static - 클래스의, 공통적인

인스턴스 변수는 하나의 클래스로부터 생성되었더라도 각기 다른 값을 유지하지만,

클래스변수(static 변수)는 인스턴스 관계없이 같은 값을 갖는다. 

**이유 : 하나의 변수를 모든 인스턴스가 공유하기 때문에**

staic이 붙은 멤버변수, 메서드, 초기화블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용할 수 있다. 

인스턴스메서드와 static메서드의 근본적인 차이는 메서드 내에서 인스턴스 멤버를 사용하는가의 여부에 있다. 

static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭

**static 멤버변수** 

- 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
- 인스턴스를 생성하지 않고도 사용가능
- 클래스가 메모리에 로드될 때 생성

**static 메서드**

- 인스턴스를 생성하지 않고도 호출이 가능하다
- static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.

**static 초기화 블럭**

- 클래스가 메모리에 로드될때, 단 한번만 수행되며 주로 클래스변수(static변수)를 초기화하는데 주로 사용된다.

---

### final - 마지막의, 변경될 수 없는

**final 클래스**

- 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
- 그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.

**final 메서드** 

- 변경될 수 없는 메서드
- final로 지정된 메서드는 오버라이딩을 통해 재정의될 수 없다.

**final 멤버변수, 지역변수**

- 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.

### 생성자를 이용한 final멤버 변수의 초기화

final이 붙은 변수는 상수이므로 보통 선언과 초기화를 동시에 하지만, **인스턴스변수의 경우 생성자에서 초기화되도록 할 수 있다.** 

**클래스 내에 매개변수를 갖는 생성자를 선언**해서 

**인스턴스를 생성할 떄 final이 붙은 멤버변수를 초기화하는데 필요한 값을 생성자의 매개변수로부터 제공받는 것**이다. 

(이것이 불가능하면 클래스에 선언된 final이 붙은 인스턴스변수는 모든 인스턴스에서 같은 값을 가져야만 할 것이다.)

예시 

카드의 경우, 카드마다 다른 종류와 숫자를 갖는다. 

카드가 **생성**되고 카드의 값이 **변경되면 안된다.**  

```java
class Card7 {
    final int NUMBER;  **//상수지만 선언과 함께 초기화하지 않고 생성자에서 단한번만 초기화**              
    final String KIND; **//할 수 있다.** 
    static intwidth= 100;
    static intheight= 250;

    **Card7(int number, String kind) { //매개변수로 넘겨받은 값으로 NUMBER와 KIND를 초기화
        NUMBER = number;
        KIND = kind;
    }**

    Card7() {
        this(7, "CLOVER");
    }

    public String toString() {
        return KIND + NUMBER;
    }
}
public class FinalCardTest {
    public static void main(String[] args) {
        Card7 c = new Card7();
        System.out.println(c.toString());

        Card7 c2 = new Card7(4,"HEART");
        //에러나는 이유 final 변수인데 즉 상수인데, 이미 생성자를 통해 초기화를 했기때문에 추가적으로 값을 변경할 수 없다.
        //c2.NUMBER = 5;
        System.out.println(c2.toString());

    }

}
```

**final이 붙은 인스턴스변수가 선언과 함께 초기화하지 않았을 경우 생성자(매개변수)를 통해 한번 초기화할 수 있다.** 

---

### abstract - 추상의, 미완성의

메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용

클래스에 사용되어 클래스 내에 추상메서드가 존재한다는 것을 쉽게 알 수 있게 해준다. 

abstract 사용될 수 있는 곳 - 클래스, 메서드 

**abstract 클래스** 

- 클래스 내에 추상 메서드가 선언되어 있음을 알려준다.

**abstract 메서드** 

- 선언부만 작성하고 구현부는 작성하지 않은 추상메서드임을 알려준다.

**추상 클래스는 아직 완성되지 않은 메서드가 존재하는 미완성 설계도 이므로 인스턴스를 생성할 수 없다.** 

---

### 접근 제어자(access modifier)

해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다. 

멤버 또는 클래스에 사용

접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자 

private - 같은 클래스 내에서만 접근 가능

default - 같은 패키지 내에서만 접근 가능

protected - 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근 가능

public - 접근 제한이 전혀 없다. 

클래스 - public, (default)

메서드, 멤버변수 - public, protected, (default), private

지역변수 - X(없음)

### 접근 제어자를 이용한 캡슐화

클래스나 멤버, 주로 멤버에 **접근 제어자를 사용하는 이유**는 

1. **클래스의 내부에 선언된 데이터를 보호하기 위해서이다.** 
    - 데이터가 유효한 값을 유지하도록 하거나, 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는 것이 필요하다. 이를 데이터 감추기라고 하며, 객체지향개념의 캡슐화에 해당한다.
2. **클래스 내에서만 사용되는, 내부 작업을 위해 임시로 사용되는 멤버변수나 부분작업을 처리하기 위한 메서드 등의 멤버들을 클래스 내부에 감추기 위해서이다.** 

- 외부로부터 데이터를 보호하기 위해
- 외부에 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서

멤버변수를 private로 제한하고 멤버변수의 값을 읽고 변경할 수 있는(getter & setter) public메서드를 제공함으로써 간접적으로 멤버변수의 값을 다룰 수 있도록 하는 것이 바람직하다. 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dcf36e0c-c4fb-4de1-bcd5-4c26714ba5e9/Untitled.png)

### 생성자의 접근 제어자

생성자에 접근 제어자를 사용함으로써 **인스턴스의 생성을 제한**할 수 있다. 

보통 생성자의 접근 제어자는 클래스의 접근 제어자와 같지만 다르게 지정할 수도 있다. 

생성자의 접근 제어자를 private로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게 된다. 그래도 클래스 내부에서는 인스턴스를 생성할 수 있다. 

대신 내부에서 인스턴스반환 메서드를 public으로 하여 외부에서 해당 클래스의 인스턴스를 사용하도록 할 수 있다. **이 메서드는 public인 동시에 static이어야한다.** 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cac438af-65d3-4483-b10c-d2a6d783ab4e/Untitled.png)

생성자를 통해 직접 인스턴스를 생성하지 못하게 하고 public메서드를 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 **인스턴스의 개수를 제한할 수 있다.**

또 한가지, **생성자가 private인 클래스**는 **다른 클래스의 조상이 될 수 없다.** 

이유 : 자손클래스의 인스턴스를 생성할 때 조상클래스의 생성자를 호출해야만 하는데, 생성자의 접근 제어자가 private이므로 자손클래스에서 호출하는 것이 불가능하기 때문에 

따라서 이럴 경우에는 클래스 앞에 final을 추가하여 상속할 수 없는 클래스라는 것을 알리는 것이 좋다. 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ff951e1f-bf4c-47a3-8e61-4bcf9e9a4b91/Untitled.png)

### 제어자의 조합

클래스 - public, (default), final, abstract

메서드 - 모든 접근 제어자, final, abstract, static

멤버변수 - 모든 접근 제어자, final, static

지역변수 - final

**주의사항**

1. 메서드에 static과 abstract를 함께 사용할 수 없다. 
    - static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문에
2. 클래스에 abstract와 final을 동시에 사용할 수 없다. 
    - 클래스에 사용되는 final은 클래스 확장이 없다는 의미이고 abstract는 상속을 통해서 완성되어야 한다는 의미여서 서로 모순이 되기 때문에
3. abstract메서드의 접근 제어자가 priavte일 수 없다. 
    - abstract메서드는 자손클래스에서 구현해줘야하는데 접근 제어자가 priavte면 자손클래스에서 접근할 수 없기 때문에
4. 메서드에 private와 final을 같이 사용할 필요는 없다. 
    - 접근제어자가 priavte인 메서드는 오버라이딩될 수 없기 때문에 둘 중 하나만 사용해도 의미가 충분하다.