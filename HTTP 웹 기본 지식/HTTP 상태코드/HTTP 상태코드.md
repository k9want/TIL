# HTTP 상태코드

### 클라이언트가 요청을 보내면 그 요청이 잘 처리가 되었는지 문제가 있는지 응답이 올때 알려주는 기능


- 1xx : 요청 수신되어 처리중(거의 사용안한다. )
- 2xx : 요청 정상 처리
- 3xx : 리다이렉션(요청을 완료하려면 추가적으로 뭔가를 해야할 필요가 있다는 것)
- 4xx : 클라이언트 오류
- 5xx : 서버 오류


## 1xx (Informational)

요청이 수신되어 처리중 (거의 안 쓴다.)

## 2xx (Successful) - 성공

클라이언트의 요청을 성공적으로 처리

- **200 OK**

  **요청 성공**


- **201 Created**

  **요청을 성공해서 새로운 리소스가 생성됨**


  201이니까 자원이 생성되었고 Location 헤더가 있을 수도 있겠구나라고 판단할 수 있다.

- **202 Accepted**

  **요청이 접수됐는데 처리가 완료되지 않았음**

    - 잘 사용하지는 않는다.
    - 배치 처리 같은 곳에서 사용
    - ex) 요청 접수 후 1시간 뒤에 배치 프로세스가 요청을 처리한다.

- **204 No Content**

  클라이언트가 요청을 하면 서버는 보통 응답값을 내보내는데 그 응답 바디에 데이터가 있는데 **서버가 성공적으로 요청을 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없을 때**

    - ex) 웹 문서 편집기에서 save 버튼 눌렀을때
    - save 버튼의 결과로 아무 내용이 없어도 된다.
    - save 버튼을 눌러도 같은 화면을 유지해야 한다.
    - 결과 내용이 없어도 204 메시지(2xx)만으로 성공을 알 수 있다.

응답코드를 사용할 때 범위를 정해서 사용하는게 좋다.

예를 들어 200 OK 랑 201 Created만 쓰자~! 할 수도 있다.

## 3xx (Redirection)

요청을 완료하기 위해 유저 에이전트(클라이언트 프로그램 주로 웹브라우저)의 추가 조치가 필요하다라는 뜻


300은 거의 안 쓰이고 301~308이 주로 쓰인다.

## 리다이렉션 이해

### 리다이렉션이 뭘까?

웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동으로 이동하는 것을 리다이렉션이라고 한다.

### 예제 - 자동 리다이렉트 흐름

/event에서 /new-event로 바꾸기로 했다고 가정해보자


1. 클라이언트에서 /event로 요청이 들어왔다고 하면
2. 서버에서는 301 응답코드와 함께 Location 헤더에 /new-event 넣어서 보내준다.
3. 응답을 받은 웹브라우저는 스스로 URL 경로창을 /new-event로 바꾸고
4. 다시 요청을 보낸다.
5. 그러면 서버가 응답을 한다.

### 종류 - 크게 3가지가 있다.


- 영구 리다이렉션 - 특정 리소스의 URI가 영구적으로 이동
    - ex) /members → /users
    - ex) /event → /new-event
- 일시 리다이렉션 - 일시적인 변경 (잠깐 이동시킬때)
    - 주문 완료 후 주문 내역 화면으로 이동시키는것
    - **PRG : POST/Redirect/Get**
- 특수 리다이렉션
    - 결과 대신 캐시를 사용하는 것


## 영구 리다이렉션 - 301, 308


- 리소스의 URI가 영구적으로 이동했다는 것을 알려준다.
- 원래의 URL을 사용하면 안된다!! 검색 엔진 등에서도 변경을 인지한다.
- **301 Moved Permanently**
    - 리다이렉트를 요청 했을 때 예를 들어 POST로 요청했는데 GET으로 바뀌고 본문이 제거될 수 있다. (항상 x , MAY)
- 308 Permanent Redirect
    - 301과 기능은 같다
    - 리다이렉트 요청 했을 떄  예를 들어 처음 POST로 보내고 리다이렉트할 때도 POST로 유지하고 데이터가 내부에 있다면 데이터를 유지한다.


### 영구 리다이렉션 - 301

/event에 POST라고 보내면서 내부의 정보가 있으면 그 사용를 등록한다고 했을떄


1. 클라이언트가 /event에 POST로 정보 입력해서 요청을 보낸다. 이때는 메시지가 존재한다.  (name=hello&age=20)
2. 근데 서버에서는/event를 안 쓰기로 해서  /new-event로 URL을 바꿔야해서 301 응답코드를 보낸다.
3. 그러면 클라이언트에서 응답을 받고 리다이렉트 요청을 하는데 GET으로 변경되고
4. GET요청이기 때문에 요청할 떄 메시지 바디부분이 사라지고
5. 서버에서는 새로운 이벤트 페이지 폼이 나오거나 새로운 이벤트페이지가 나오거나 결국은 새로운 페이지를 보내기 때문에
6. 클라이언트에서는 처음부터 다시 데이터를 입력하고 POST요청을 해야한다.

이를 해결하기 위해 308이 있다.

### 영구 리다이렉션 - 308

1. 클라이언트가 서버로 요청을 보낼때 POST를 사용해서 보낸다. (/event)
2. 서버에서 308로 응답하면 (헤더에 Location : /new-event)
3. 클라이언트에서는 POST 유지하면서 /new-event로 리다이렉션 요청을 한다.
4. 이 때는 POST도 유지하고 메시지 본문도 유지해서 보낸다.
5. 서버 응답 완료

실무에서는 거의 308을 사용하지 않는데 왜냐하면 /event → /new-event로 바뀌어버리면 내부적으로 전달해야하는 데이터 자체가 다 바뀌어버리기 때문에 POST로 와도 GET으로 돌리는게 맞다.

근데!! 301도 그렇게 많이 쓰이지는 않는다.

실무에서는 일시적인 리다이렉션을 많이 사용한다고 한다.

## 일시적인 리다이렉션 - 302, 307, 308


- 리소스의 URI가 일시적으로 변경
- 따라서 검색 엔진 등에서 URL을 변경하면 안된다.
- **302 Found - 대부분 GET으로 변경**
    - **리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있다. (MAY - 안될 수도 있다. 대부분은 GET으로 변한다.)**
- **307 Temporary Redirect - 유지**
    - 302와 기능은 같음
    - **리다이렉트시 요청 메서드와 본문 유지(요청 메서드를 변경하면 안된다.MUST NOT)**
- **303 See Other - 명확하게 GET으로 변경**
    - 302와 기능은 같음
    - **리다이렉트시 요청 메서드가 GET으로 변경된다.**

그러면 일시적인 리다이렉션을 언제 사용할까?

### PRG : POST/Redirect/Get

일시적인 리다이렉션 - 예시


- **POST로 주문하고 웹 브라우저를 새로고침하면??**
    - 새로고침은 다시 요청하게 된다.
    - 그래서 중복 주문이 될 수 있다.

### PRG 사용전


**/order에 주문을 한다고 가정하자.**

1. POST /order로  URI 요청을 보내면 itemId = mouse로 했다고 하면
2. 서버에서 주문데이터를 저장하고 mouse 1개
3. 응답을 보낸다.

여기서 클라이언트의 마지막 요청은??? 1의  POST /order 요청이다.

1. 이럴 경우 결과화면에서 새로고침을 눌렀을때 (마지막 요청이 새로고침되기 때문에)
2. 1의 요청이 다시 보내진다.
3. 주문데이터 또 저장되고
4. 응답을 또 받는다.

원래 원칙적으로는 주문번호를 통해서 중복 주문이거나 잘못된 주문이라고 서버에서 막아야하지만 그래도 클라이언트에서도 막아주는게 좋다.

**이 문제를 해결하기 위해 보통 PRG 패턴을 사용한다.**


- POST로 주문후에 새로 고침으로 인한 중복 주문 방지 (사용자 사용성에도 효율적이다)
- POST로 주문후에 주문 결과 화면을 GET 메서드로 리다이렉트
- 새로고침을 해도 결과 화면을 GET으로 조회
- 중복 주문 대신에 결과 화면만 GET으로 다시 요청한다.

### **PRG - Post/Redirect/Get**


1. 클라이언트에서 POST로 주문 요청 보내면
2. 서버에서는 주문데이터 저장
3. 302 Found 또는 303 See other 응답코드와 Location 정보를 가지고 있는 응답을 보낸다.
4. 클라이언트가 자동으로 GET 사용해서
5. Location을 확인하고 리다이렉션 요청을 한다.
6. 서버에서는 주문데이터 조회하고
7. 응답해준다.
8. 그러면 결과화면에서 새로고침을 해도 GET요청으로 주문 결과 화면만 다시 요청해준다.(5 요청 같다)


**PRG 이후에 리다이렉트하면**

- **URL이 이미 POST → GET으로 리다이렉트 되기 때문에**
- **새로 고침해도 GET으로 결과 화면만 조회된다.**

### 그래서 뭘 써야 할까? 302, 307, 303 중에


현실적으로는 307, 303을 권장하지만 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용하고 있다.

따라서 자동 리다이렉션시에 GET으로 변해도 되면 그냥 302를 사용해도 문제없다.

## 기타 리다이렉션 - 300. 304


- 300 Multiple Choices: 안 쓴다.
- **304 Not Modified**
    - 캐시를 목적으로 사용한다.
    - 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용한다. (캐시로 리다이렉트 한다.)
    - 304 응답은 응답에 메시지 바디를 포함하면 안 된다. (로컬 캐시를 사용하기 때문에)
    - 조건부 GET, HEAD 요청시 사용


## 4xx (Client Error) - 클라이언트 오류


- 클라이언트의 요청에 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
- **오류의 원인이 클라이언트에 있음**
- **중요한 것은!!! 클라이언트가 이미 잘못된 요청, 데이터를 보내고 있기 때문에, 똑같은 재시도가 실패한다. (5xx 오류는 성공할 가능성이 있다.)**

### 400 Bad Request -  클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음


- 요청 구문, 메시지 등등 오류
- 클라이언트는 요청 내용을 다시 검토하고, 보내야한다.
- ex) 요청 파라미터가 잘못되거나, API 스펙이 맞지 않을 때
- 서버 개발자는 validation을 잘해서 미리 차단을 해야한다.

### 401 Unauthorized - 클라이언트가 해당 리소스에 대한 인증이 필요함


- 인증(Authentication) 되지 않았다는 뜻
- 4**01 오류의 응답에는 WWW-Authenticate 헤더와 함께 인증 방법을 설명해줘야한다.**
- 오류 메시지가 Unauthorized 이지만! 인증 되지 않은 것을 의미한다 (이름이 ..... )

참고

- **인증(Authentication)** - 로그인 유/무
- **인가(Authorization)** - 특정 리소스에 접근할 수 있는 권한

### 403 Forbidden - 서버가 요청을 이해했지만 승인을 거부함 (권한이 없는 경우)


- 주로 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우
- ex) admin 등급이 아닌 사용자가 로그인은 했지만, admin 등급의 리소스에 접근하는 경우

### 404 Not Found

요청 리소스를 찾을 수 없다.

- 요청 리소스가 서버에 없다
- 클라이언트가 권한이 부족한 리소스에 접근했는데 리소스를 숨기고 싶어서 403을 보여주고 싶지 않을 때

## 5xx (Server Error) - 서버 오류


- 서버 문제로 오류 발생
- 서버에 문제가 있기 때문에 재시도 하면 성공할 수도 있음(복구가 되거나 등등 상황에서)

### 500 Internal Server Error - 서버 문제로 오류 발생, 애매하면 500 오류


### 503  Service Unavailable - 서비스 이용 불가


- 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없다.
- Retry-After 헤더 필드로 얼마 뒤에 복구되는지 보낼 수도 있다.
- 하지만 보통은 서버가 갑자기 다운되는 경우가 많기 때문에 주로 500을 .....보낸다고....한다

5xx 에러는 진짜 서버가 안 되는 경우일때만 사용한다.

예를 들어 20세이상만 가능한 컨텐츠에 15세가 들어왔다면?? 이것은 프로세스는 잘 처리가 된 것이다. 비즈니스 로직이나 예외처리를 잘못한 경우기 때문에 5xx에러로 생각하면 안된다.